/*
 * Copyright (C) 2026 Viktor Alexander Hartung
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.hartrusion.rbmksim.gui.elements;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.geom.Arc2D;
import java.awt.geom.Line2D;
import java.beans.BeanProperty;

/**
 * An ampere meter, used to display some value with a pointer that is fixed in
 * the lower middle. Called ammeter (short for ampere meter) as those things are
 * moving their pointer according to the current value but they can be used to
 * display other values too.
 *
 * @author Viktor Alexander Hartung
 */
public class Ammeter extends javax.swing.JComponent {

    private double value;
    private int width, height;
    private float centerY, centerX;
    private float pointerLength;
    private float arcX, arcY, arcD;
    private float lowerHeigt, lowerStart;

    private String leftLabel = "0.0";
    private String rightLabel = "100";

    /**
     * Creates new form Ammeter
     */
    public Ammeter() {
        initComponents();
    }

    public double getChornobylValue() {
        return value;
    }

    @BeanProperty(preferred = true, visualUpdate = true, description
            = "Sets the pointer position between 0 and 100")
    public void setChornobylValue(double value) {
        if (value < 0.0) {
            value = 0.0;
        } else if (value > 100) {
            value = 100;
        }
        double old = this.value;
        this.value = value;
        firePropertyChange("chornobylValue", old, value);
        repaint();
    }

    public String getLeftLabel() {
        return leftLabel;
    }

    @BeanProperty(preferred = true, visualUpdate = true, description
            = "Text on the lower left")
    public void setLeftLabel(String leftLabel) {
        String old = this.leftLabel;
        if (old != leftLabel) {
            this.leftLabel = leftLabel;
            firePropertyChange("leftLabel", old, leftLabel);
            repaint();
        }
    }

    public String getRightLabel() {
        return rightLabel;
    }

    @BeanProperty(preferred = true, visualUpdate = true, description
            = "Text on the lower right")
    public void setRightLabel(String rightLabel) {
        String old = this.rightLabel;
        if (old != rightLabel) {
            this.rightLabel = rightLabel;
            firePropertyChange("rightLabel", old, rightLabel);
            repaint();
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setPreferredSize(new java.awt.Dimension(40, 30));
        setLayout(null);
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2d = (Graphics2D) g;
        if (getWidth() != width || getHeight() != height) {
            width = getWidth();
            height = getHeight();
            calculateStaticCoordinates();
        }
        // Force the use of antialiasing to not look like 1997
        Object prevHint = g2d.getRenderingHint(RenderingHints.KEY_ANTIALIASING);
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON);

        // Draw background recticle
        g2d.setColor(getBackground());
        g2d.fillRect(0, 0, width, height);

        // the line behind the moving pointer
        Arc2D.Float arc = new Arc2D.Float(arcX, arcY, arcD, arcD,
                45.0F, 90.0F, Arc2D.OPEN);
        g2d.setStroke(new BasicStroke(2F));
        g2d.setColor(getForeground());
        g2d.draw(arc);

        // Draw the Pointer line. Clip the lower part away
        Shape oldClip = g2d.getClip();
        g2d.setClip(0, 0, width, (int) lowerStart);
        float phi = (float) (value * 0.01570796326795);
        Line2D.Float line = new Line2D.Float(centerX, centerY,
                getXCoordinate(pointerLength, phi),
                getYCoordinate(pointerLength, phi));
        g2d.setStroke(new BasicStroke(1F));
        g2d.draw(line);
        g2d.setClip(oldClip); // revert clip settings.

        // Text on the lower sides
        Font oldFont = g.getFont();
        g.setFont(oldFont.deriveFont(oldFont.getSize() - 4.0F)); // smaller
        FontMetrics fm = g.getFontMetrics();
        if (leftLabel != null) {
            g.drawString(leftLabel,
                    4,
                    height - 4);
        }
        if (rightLabel != null) {
            g.drawString(rightLabel,
                    width - fm.stringWidth(rightLabel) - 4,
                    height - 4);
        }

        // Reset the previous font value
        g.setFont(oldFont);
        // Reset the antialiasing to its previous value
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, prevHint);
    }

    private void calculateStaticCoordinates() {
        float width = (float) this.width;
        float height = (float) this.height;
        pointerLength = Math.min(width * 0.5F, height * 0.8F);
        centerX = width / 2.0F;
        centerY = pointerLength * 1.15F;
        // coordinates of the arc line
        arcX = centerX - pointerLength * 0.8F;
        arcY = centerY - pointerLength * 0.8F;
        arcD = 2.0F * pointerLength * 0.8F;
        // Coordinates for the lower rectangle (hides the lower part of the 
        // indicator
        lowerStart = pointerLength * 1.0F;
        lowerHeigt = height - lowerStart;
    }

    /**
     * Calculates the X coordinate for a point on the gauge
     *
     * @param r raduis from pointer center
     * @param phi phi from 0..pi/2
     * @return
     */
    private float getXCoordinate(float r, float phi) {
        phi = phi - 0.78539816339745F; // -pi/4
        return centerX + (float) Math.sin((double) phi) * r;
    }

    /**
     * Calculates the X coordinate for a point on the gauge
     *
     * @param r raduis from pointer center
     * @param phi phi from 0..pi/2
     * @return
     */
    private float getYCoordinate(float r, float phi) {
        phi = phi - 0.78539816339745F; // +pi/4
        return centerY - (float) Math.cos((double) phi) * r;
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
