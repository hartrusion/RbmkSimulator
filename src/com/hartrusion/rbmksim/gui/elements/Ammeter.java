/*
 * Copyright (C) 2026 Viktor Alexander Hartung
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.hartrusion.rbmksim.gui.elements;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.geom.Arc2D;
import java.awt.geom.Line2D;
import java.beans.BeanProperty;

/**
 *
 * @author viktor
 */
public class Ammeter extends javax.swing.JComponent {
    double value;
    int width, height;
    float centerY, centerX;
    float pointerLength;
    float arcX, arcY, arcD;
    float lowerHeigt, lowerStart;

    /**
     * Creates new form Ammeter
     */
    public Ammeter() {
        initComponents();
    }
    
    public double getChornobylValue() {
        return value;
    }

    @BeanProperty(preferred = true, visualUpdate = true, description
            = "Sets the pointer position between 0 and 100")
    public void setChornobylValue(double value) {
        if (value < 0.0) {
            value = 0.0;
        } else if (value > 100) {
            value = 100;
        }
        double old = this.value;
        this.value = value;
        firePropertyChange("chornobylValue", old, value);
        repaint();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setPreferredSize(new java.awt.Dimension(40, 30));
        setLayout(null);
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2d = (Graphics2D) g;
        if (getWidth() != width || getHeight() != height) {
            width = getWidth();
            height = getHeight();
            calculateStaticCoordinates();
        }
        // Force the use of antialiasing to not look like 1997
        Object prevHint = g2d.getRenderingHint(RenderingHints.KEY_ANTIALIASING);
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON);
        
        // Draw background recticle
        g2d.setColor(getBackground());
        g2d.fillRect(0, 0, width, height);
        
        // the line behind the moving pointer
        Arc2D.Float arc = new Arc2D.Float(arcX, arcY, arcD, arcD,
                45.0F, 90.0F, Arc2D.OPEN);
        g2d.setStroke(new BasicStroke(2F));
        g2d.setColor(getForeground());
        g2d.draw(arc);
        
        // Draw the Pointer line. Clip the lower part away
        Shape oldClip = g2d.getClip();
        g2d.setClip(0,0,width, (int) lowerStart);
        float phi = (float) (value * 0.01570796326795);
        Line2D.Float line = new Line2D.Float(centerX, centerY, 
                getXCoordinate(pointerLength, phi), 
                getYCoordinate(pointerLength, phi));
        g2d.setStroke(new BasicStroke(1F));
        g2d.draw(line);
        g2d.setClip(oldClip); // revert clip settings.
        
        // Reset the antialiasing to its previous value
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, prevHint);
    }

    private void calculateStaticCoordinates() {
        float width = (float) this.width;
        float height = (float) this.height;
        pointerLength = Math.min(width * 0.5F, height * 0.8F);
        centerX = width / 2.0F;
        centerY = pointerLength * 1.15F;
        // coordinates of the arc line
        arcX = centerX - pointerLength * 0.8F;
        arcY = centerY - pointerLength * 0.8F;
        arcD = 2.0F * pointerLength * 0.8F;
        // Coordinates for the lower rectangle (hides the lower part of the 
        // indicator
        lowerStart = pointerLength * 1.0F;
        lowerHeigt = height - lowerStart;
    }

    /**
     * Calculates the X coordinate for a point on the gauge
     *
     * @param r raduis from pointer center
     * @param phi phi from 0..pi/2
     * @return
     */
    private float getXCoordinate(float r, float phi) {
        phi = phi - 0.78539816339745F; // -pi/4
        return centerX + (float) Math.sin((double) phi) * r;
    }

    /**
     * Calculates the X coordinate for a point on the gauge
     *
     * @param r raduis from pointer center
     * @param phi phi from 0..pi/2
     * @return
     */
    private float getYCoordinate(float r, float phi) {
        phi = phi - 0.78539816339745F; // +pi/4
        return centerY - (float) Math.cos((double) phi) * r;
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
