/*
 * Copyright (C) 2026 Viktor Alexander Hartung
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.hartrusion.rbmksim.gui.elements;

import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.geom.Arc2D;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Path2D;
import java.beans.BeanProperty;

/**
 * A synchroscope gauge used to display the difference between rotation of the
 * generator shaft and the grid rotational field for syncing the generator.
 *
 * @author Viktor Alexander Hartung
 */
public class Synchroscope extends javax.swing.JComponent {

    private static final float PI_HALF = 1.5707963267949F;

    private int oldWidth, oldHeight, size;

    private float pointerWidth, pointerLength;

    private float phiValue = 0;

    private static final float ARC_RADIUS_RATIO = 0.4F;
    private static final float ARC_START_ANGLE_OFFSET = 0.3F;
    private static final float ARC_END_ANGLE_OFFSET = -0.4F;
    private static final float ARROW_LENGTH_RATIO = 0.08F;
    private static final float ARROW_WIDTH_RATIO = 0.8F;
    private static final float CENTER_CIRCLE_DIAMETER_RATIO = 0.15F;

    // pre-cached shapes
    private Arc2D.Float leftArc;
    private Arc2D.Float rightArc;
    private Path2D.Float leftArrow;
    private Path2D.Float rightArrow;
    private Ellipse2D.Float centerCircle;

    /**
     * Creates new form Synchroscope
     */
    public Synchroscope() {
        initComponents();
    }

    public float getChornobylPhiValue() {
        return phiValue;
    }

    @BeanProperty(preferred = true, visualUpdate = true, description
            = "Sets the current angle to display in radiants (pi thing)")
    public void setChornobylPhiValue(float phiValue) {
        double old = this.phiValue;
        this.phiValue = phiValue;
        firePropertyChange("chornobylValue", old, phiValue);
        repaint();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 80, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 80, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2d = (Graphics2D) g;

        // Only do a calculation run on size change.
        if (oldWidth != getWidth() || oldHeight != getHeight()) {
            oldWidth = getWidth();
            oldHeight = getHeight();
            size = Math.min(oldWidth, oldHeight);
            pointerWidth = 0.08F * (float) size * 0.5F;
            pointerLength = 0.4F * (float) size * 1.05F;

            // precalculate static shapes
            float cx = size * 0.5F;
            float cy = size * 0.5F;
            float arcRadius = size * ARC_RADIUS_RATIO;
            float arcX = cx - arcRadius;
            float arcY = cy - arcRadius;
            float arcW = arcRadius * 2.0F;
            float arcH = arcRadius * 2.0F;

            float topOffsetDeg = (float) Math.toDegrees(ARC_START_ANGLE_OFFSET);
            float bottomOffsetDeg = (float) Math.toDegrees(ARC_END_ANGLE_OFFSET);

            float startAngleRight = 90.0F - topOffsetDeg;
            float extentRight = -(90.0F - topOffsetDeg - bottomOffsetDeg);
            rightArc = new Arc2D.Float(arcX, arcY, arcW, arcH, startAngleRight, extentRight, Arc2D.OPEN);

            float startAngleLeft = 90.0F + topOffsetDeg;
            float extentLeft = 90.0F - topOffsetDeg - bottomOffsetDeg;
            leftArc = new Arc2D.Float(arcX, arcY, arcW, arcH, startAngleLeft, extentLeft, Arc2D.OPEN);

            float arrowLen = size * ARROW_LENGTH_RATIO;
            float arrowWidth = arrowLen * ARROW_WIDTH_RATIO;

            float phiRightEnd = PI_HALF - ARC_END_ANGLE_OFFSET;
            float rightTipX = getXCoordinate(arcRadius, phiRightEnd);
            float rightTipY = getYCoordinate(arcRadius, phiRightEnd);
            rightArrow = createArrowHead(rightTipX, rightTipY, phiRightEnd, arrowLen, arrowWidth);

            float phiLeftEnd = -PI_HALF + ARC_END_ANGLE_OFFSET;
            float leftTipX = getXCoordinate(arcRadius, phiLeftEnd);
            float leftTipY = getYCoordinate(arcRadius, phiLeftEnd);
            leftArrow = createArrowHead(leftTipX, leftTipY, phiLeftEnd + (float) Math.PI, arrowLen, arrowWidth);

            float centerCircleDia = size * CENTER_CIRCLE_DIAMETER_RATIO;
            float centerCircleRad = centerCircleDia * 0.5F;
            centerCircle = new Ellipse2D.Float(cx - centerCircleRad, cy - centerCircleRad, centerCircleDia, centerCircleDia);

        }

        // Force the use of antialiasing to not look like 1997
        Object prevHint = g2d.getRenderingHint(RenderingHints.KEY_ANTIALIASING);
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON);

        // Draw background recticle
        g2d.setColor(getBackground());
        g2d.fillRect(0, 0, size - 1, size - 1);
        g2d.setColor(getForeground());
        g2d.drawRect(0, 0, size - 1, size - 1);

        // Draw precached shapes
        g2d.draw(rightArc);
        g2d.draw(leftArc);
        g2d.fill(rightArrow);
        g2d.fill(leftArrow);

        // generate the pointer as a triangle
        Path2D.Float triangle = new Path2D.Float();
        // path through 3 points:
        triangle.moveTo(getXCoordinate(pointerWidth, phiValue - PI_HALF),
                getYCoordinate(pointerWidth, phiValue - PI_HALF));
        triangle.lineTo(getXCoordinate(pointerLength, phiValue),
                getYCoordinate(pointerLength, phiValue));
        triangle.lineTo(getXCoordinate(pointerWidth, phiValue + PI_HALF),
                getYCoordinate(pointerWidth, phiValue + PI_HALF));
        triangle.closePath();
        g2d.fill(triangle);

        if (centerCircle != null) {
            g2d.fill(centerCircle);
        }

        // Reset the antialiasing to its previous value
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, prevHint);
    }

    /**
     * Calculate the X coordinate for given R and phi for a rotation around the
     * center.
     *
     * @param R radius (subpixel double)
     * @param phi in radians (the thing with pi)
     * @return X coordinate (subpixel double)
     */
    private float getXCoordinate(float r, float phi) {
        return size * 0.5F + (float) Math.sin((double) phi) * r;
    }

    /**
     * Calculate the Y coordinate for given R and phi for a rotation around the
     * center.
     *
     * @param R radius (subpixel double)
     * @param phi in radians (the thing with pi)
     * @return X coordinate (subpixel double)
     */
    private float getYCoordinate(float r, float phi) {
        return size * 0.5F - (float) Math.cos((double) phi) * r;
    }

    /**
     * Creates an arrow head shape with provided coordinates
     *
     * @param tipX tip x coordinate
     * @param tipY tip y coordinate
     * @param dir direction (radiants)
     * @param length arrow length
     * @param width arrow width at its base
     * @return Path2D.Float calculated arrow head
     */
    private Path2D.Float createArrowHead(float tipX, float tipY, float dir, 
            float length, float width) {
        float dx = (float) Math.cos(dir) * length;
        float dy = (float) Math.sin(dir) * length;

        float baseX = tipX - dx;
        float baseY = tipY - dy;

        float perpX = (float) -Math.sin(dir) * width * 0.5F;
        float perpY = (float) Math.cos(dir) * width * 0.5F;

        Path2D.Float head = new Path2D.Float();
        head.moveTo(tipX, tipY);
        head.lineTo(baseX + perpX, baseY + perpY);
        head.lineTo(baseX - perpX, baseY - perpY);
        head.closePath();

        return head;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
