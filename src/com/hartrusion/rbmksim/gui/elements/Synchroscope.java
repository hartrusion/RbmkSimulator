package com.hartrusion.rbmksim.gui.elements;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Path2D;
import java.beans.BeanProperty;

/**
 * A synchroscope
 *
 * @author viktor
 */
public class Synchroscope extends javax.swing.JComponent {

    private static final float PI_HALF = 1.5707963267949F;

    private int oldWidth, oldHeight, size;

    private float pointerWidth, pointerLength;

    private float phiValue = 0;

    /**
     * Creates new form Synchroscope
     */
    public Synchroscope() {
        initComponents();
    }
    
    public float getChornobylPhiValue() {
        return phiValue;
    }

    @BeanProperty(preferred = true, visualUpdate = true, description
            = "Sets the current angle to display in radiants (pi thing)")
    public void setChornobylPhiValue(float phiValue) {
        double old = this.phiValue;
        this.phiValue = phiValue;
        firePropertyChange("chornobylValue", old, phiValue);
        repaint();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 80, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 80, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2d = (Graphics2D) g;

        // Only do a calculation run on size change.
        if (oldWidth != getWidth() || oldHeight != getHeight()) {
            oldWidth = getWidth();
            oldHeight = getHeight();
            size = Math.min(oldWidth, oldHeight);
//            outerRingRadius = 0.45F * (float) size;
//            outerTickRadius = 0.4F * (float) size;
//            majorTicksInnerRadius = outerTickRadius * 0.8F;
//            minorTicksInnerRadius = outerTickRadius * 0.9F;
//            innerCircleRadius = 0.08F * (float) size;
            pointerWidth = 0.08F * (float) size * 0.5F;
            pointerLength = 0.4F * (float) size * 1.05F;
//            indicatorSize = size * 0.14F;
//            halfSize = size * 0.5F;

            // This calls sin and cosine a lot, so we will have this calculated
            // only once and just draw the shapes stored in those lists
//            majorTickLines.clear();
//            for (int idx = 0; idx < majorTicks.length; idx++) {
//                majorTickLines.add(getLine(majorTicksInnerRadius, 
//                        outerTickRadius,
//                        getPhi((double) majorTicks[idx])));
//            }
//            minorTickLines.clear();
//            for (int idx = 0; idx < minorTicks.length; idx++) {
//                minorTickLines.add(getLine(minorTicksInnerRadius, 
//                        outerTickRadius,
//                        getPhi((double) minorTicks[idx])));
//            }
        }

        // Force the use of antialiasing to not look like 1997
        Object prevHint = g2d.getRenderingHint(RenderingHints.KEY_ANTIALIASING);
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON);
        
        // Draw background recticle
        g2d.setColor(getBackground());
        g2d.fillRect(0, 0, size-1, size-1);
        g2d.setColor(getForeground());
        g2d.drawRect(0, 0, size-1, size-1);
//        // Draw background
//        Ellipse2D.Float circle;
//        g2d.setColor(Color.WHITE);
//        circle = new Ellipse2D.Float(
//                halfSize - outerRingRadius,
//                halfSize - outerRingRadius,
//                2.0F * outerRingRadius, 2.0F * outerRingRadius);
//        g2d.fill(circle);
//        // Draw the outer ring using foreground color.
//        g2d.setColor(getForeground());
//        g2d.draw(circle);
//        // draw major tick lines
//        g2d.setColor(Color.BLACK);
//        for (Shape s : majorTickLines) {
//            g2d.draw(s);
//        }
//        // Draw minor tick lines
//        for (Shape s : minorTickLines) {
//            g2d.draw(s);
//        }
//        // draw the inner cirle:
//        circle = new Ellipse2D.Float(
//                halfSize - innerCircleRadius,
//                halfSize - innerCircleRadius,
//                2.0F * innerCircleRadius, 2.0F * innerCircleRadius);
//        g2d.fill(circle);

        // generate the pointer as a triangle
        Path2D.Float triangle = new Path2D.Float();
        // path through 3 points:
        triangle.moveTo(getXCoordinate(pointerWidth, phiValue - PI_HALF),
                getYCoordinate(pointerWidth, phiValue - PI_HALF));
        triangle.lineTo(getXCoordinate(pointerLength, phiValue),
                getYCoordinate(pointerLength, phiValue));
        triangle.lineTo(getXCoordinate(pointerWidth, phiValue + PI_HALF),
                getYCoordinate(pointerWidth, phiValue + PI_HALF));
        triangle.closePath();
        g2d.fill(triangle);

        // Reset the antialiasing to its previous value
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, prevHint);
    }

    /**
     * Calculate the X coordinate for given R and phi for a rotation around the
     * center.
     *
     * @param R radius (subpixel double)
     * @param phi in radians (the thing with pi)
     * @return X coordinate (subpixel double)
     */
    private float getXCoordinate(float r, float phi) {
        return size * 0.5F + (float) Math.sin((double) phi) * r;
    }

    /**
     * Calculate the Y coordinate for given R and phi for a rotation around the
     * center.
     *
     * @param R radius (subpixel double)
     * @param phi in radians (the thing with pi)
     * @return X coordinate (subpixel double)
     */
    private float getYCoordinate(float r, float phi) {
        return size * 0.5F - (float) Math.cos((double) phi) * r;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
