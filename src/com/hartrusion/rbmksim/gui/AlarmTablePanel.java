package com.hartrusion.rbmksim.gui;

import com.hartrusion.alarm.AlarmObject;
import com.hartrusion.alarm.AlarmState;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.List;
import java.util.Map;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.Timer;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableColumn;

/**
 * Generated by Github Copilot AI (GPT 5.2)
 * 
 * Alarm table view:
 * - Columns: Description, State
 * - Filters/ordering:
 *   - state == NONE && acknowledged == true -> not shown
 *   - acknowledged == false -> sorted to top
 *   - within groups sorted by state priority:
 *     MAX2, MIN2, MAX1, MIN1, HIGH2, LOW2, HIGH1, LOW1 (then description/component)
 * - Blinking every 500ms:
 *   - ack == false && state != NONE -> red background blink
 *   - ack == false && state == NONE -> blink without background (text blink)
 */
public class AlarmTablePanel extends JPanel {

    private final AlarmTableModel model = new AlarmTableModel();
    private final JTable table = new JTable(model);

    // toggled by Swing Timer on EDT
    private volatile boolean blinkOn = true;

    private final Timer blinkTimer;

    public AlarmTablePanel() {
        super(new BorderLayout());

        table.setFillsViewportHeight(true);
        table.setRowHeight(Math.max(18, table.getRowHeight()));
        table.setFont(table.getFont().deriveFont(Font.PLAIN, 13f));
        table.getTableHeader().setReorderingAllowed(false);

        // Renderer handles blinking + background rules
        AlarmCellRenderer renderer = new AlarmCellRenderer(() -> blinkOn, model);
        table.setDefaultRenderer(Object.class, renderer);

        add(new JScrollPane(table), BorderLayout.CENTER);

        // Make State column fixed-ish at 50px
        // Column indices: 0=Description, 1=State
        TableColumn stateCol = table.getColumnModel().getColumn(1);
        stateCol.setPreferredWidth(50);
        stateCol.setMinWidth(50);
        stateCol.setMaxWidth(50);

        // 500ms blink
        blinkTimer = new Timer(500, e -> {
            blinkOn = !blinkOn;
            table.repaint();
        });
        blinkTimer.setRepeats(true);
        blinkTimer.start();
        
        table.setRowSelectionAllowed(false);
        table.setColumnSelectionAllowed(false);
        table.setCellSelectionEnabled(false);
        table.setFocusable(false);
    }

    /**
     * Call this from your 100ms EDT update hook (or whenever you get new data).
     * This method is expected to be called on the EDT already.
     */
    public void setAlarms(List<AlarmObject> alarms) {
        model.setAlarms(alarms);
    }

    /** Optional cleanup if you create/destroy this panel dynamically. */
    public void stopBlinking() {
        blinkTimer.stop();
    }

    // -------------------------
    // Table model
    // -------------------------
    private static final class AlarmTableModel extends AbstractTableModel {
        private final List<AlarmObject> visible = new ArrayList<>();

        private static final String[] COLS = {"Description", "State"};

        // Lower number => higher priority (top)
        private static final Map<AlarmState, Integer> STATE_PRIORITY = buildPriorityMap();

        private static Map<AlarmState, Integer> buildPriorityMap() {
            EnumMap<AlarmState, Integer> m = new EnumMap<>(AlarmState.class);

            // Requested order (top -> bottom):
            // MAX2, MIN2, MAX1, MIN1, HIGH2, LOW2, HIGH1, LOW1
            m.put(AlarmState.MAX2, 0);
            m.put(AlarmState.MIN2, 1);
            m.put(AlarmState.MAX1, 2);
            m.put(AlarmState.MIN1, 3);
            m.put(AlarmState.HIGH2, 4);
            m.put(AlarmState.LOW2, 5);
            m.put(AlarmState.HIGH1, 6);
            m.put(AlarmState.LOW1, 7);

            // Anything else (including NONE) goes after, stable-ish
            // (NONE acknowledged is filtered out anyway)
            return m;
        }

        private static int priorityOf(AlarmState s) {
            if (s == null) return Integer.MAX_VALUE;
            Integer p = STATE_PRIORITY.get(s);
            if (p != null) return p;
            // Put NONE and unknown states behind the known ones.
            return Integer.MAX_VALUE - 1;
        }
        
        private static boolean isNoneState(AlarmObject ao) {
            return ao.getState() == AlarmState.NONE;
        }

        public void setAlarms(List<AlarmObject> alarms) {
            visible.clear();
            if (alarms != null) {
                for (AlarmObject ao : alarms) {
                    if (ao == null) continue;

                    AlarmState state = ao.getState();
                    boolean ack = ao.isAcknowledged();

                    // Filter: state == NONE && acknowledged == true => not shown
                    if (state == AlarmState.NONE && ack) {
                        continue;
                    }
                    visible.add(ao);
                }
            }

            // Sort order (top -> bottom):
            // 1) state != NONE first (so "NONE but unack" is always below active alarms)
            // 2) unacknowledged first (within each group)
            // 3) state priority (within each group; NONE will naturally sink further)
            // 4) description/component for stable order
            Collections.sort(visible, Comparator
                    .comparing((AlarmObject ao) -> isNoneState(ao))          // false (active) first, true (NONE) last
                    .thenComparing((AlarmObject ao) -> ao.isAcknowledged())  // false first
                    .thenComparingInt(ao -> priorityOf(ao.getState()))
                    .thenComparing(ao -> nullSafe(ao.getDescription()))
                    .thenComparing(ao -> nullSafe(ao.getComponent()))
            );

            fireTableDataChanged();
        }

        public AlarmObject getAlarmAt(int row) {
            if (row < 0 || row >= visible.size()) return null;
            return visible.get(row);
        }

        @Override
        public int getRowCount() {
            return visible.size();
        }

        @Override
        public int getColumnCount() {
            return COLS.length;
        }

        @Override
        public String getColumnName(int column) {
            return COLS[column];
        }

        @Override
        public Object getValueAt(int rowIndex, int columnIndex) {
            AlarmObject ao = visible.get(rowIndex);
            return switch (columnIndex) {
                case 0 -> nullSafe(ao.getDescription());
                case 1 -> (ao.getState() != null ? ao.getState().toString() : "");
                default -> "";
            };
        }

        private static String nullSafe(String s) {
            if (s == null) {
                return "null";
            } else {
                return s;
            }
        }
    }

    // -------------------------
    // Renderer (blinking + colors)
    // -------------------------
    private static final class AlarmCellRenderer extends DefaultTableCellRenderer {
        private final BlinkState blinkState;
        private final AlarmTableModel model;

        private static final Color BLINK_BG = new Color(51, 51, 51);
        private static final Color BLINK_FG = new Color(0, 255, 153);
        private static final Color DEFAULT_BG = Color.WHITE;
        private static final Color DEFAULT_FG = Color.BLACK;

        // for state==NONE && ack==false: blink text (no background)
        private static final Color BLINK_TEXT = new Color(200, 120, 0);

        interface BlinkState {
            boolean isOn();
        }

        AlarmCellRenderer(BlinkState blinkState, AlarmTableModel model) {
            this.blinkState = blinkState;
            this.model = model;
            setOpaque(true);
        }

        @Override
        public Component getTableCellRendererComponent(
                JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column
        ) {
            super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);

            AlarmObject ao = model.getAlarmAt(row);
            if (ao == null) {
                return this;
            }

            AlarmState state = ao.getState();
            boolean ack = ao.isAcknowledged();

            boolean blink = !ack;
            boolean blinkOn = blinkState.isOn();

            Color bg = DEFAULT_BG;
            Color fg = DEFAULT_FG;
            Font font = table.getFont().deriveFont(Font.BOLD);

            if (blink) {
                if (state != null && state != AlarmState.NONE) {
                    // unacknowledged alarm: blink red background (only on-phase)
                    if (blinkOn) {
                        bg = BLINK_BG;
                        fg = BLINK_FG;
                        font = table.getFont().deriveFont(Font.BOLD);
                    }
                } else {
                    // state == NONE but not acknowledged: blink WITHOUT background -> blink text
                    if (blinkOn) {
                        // fg = BLINK_TEXT;
                        fg = DEFAULT_BG;
                        font = table.getFont().deriveFont(Font.BOLD);
                    }
                }
            }

            // Selection: keep Swing selection colors
            if (isSelected) {
                bg = table.getSelectionBackground();
                fg = table.getSelectionForeground();
            }

            setBackground(bg);
            setForeground(fg);
            setFont(font);

            return this;
        }
    }
}